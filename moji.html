<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>画面全域キャンバス</title>
  <!-- ドットフォントとして「Press Start 2P」を使用 -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden; /* スクロールバー非表示 */
      background-color: #ffffff;
    }
    /* 画面全体に表示するキャンバス */
    canvas {
      display: block;
      background-color: #ffffff;
    }
  </style>
</head>
<body>
  <canvas id="appletCanvas"></canvas>

  <script>
    // ◆◆◆ ここで改行を含む文字列を設定 ◆◆◆
    const config = {
      Title: "ありがとう\n会えるの\n楽しみ", // 複数行のテキスト
      backgroundColor: "#ffffff",
      pixelSize: 16,            // 1ブロックの大きさ
      animationInterval: 50,    // アニメーション更新のインターバル（ミリ秒）
      imageSwitchInterval: 50,  // 画像切り替えのインターバル（ミリ秒）
      imageBaseString: "img",   // ブロック画像ファイルのベース名 (例: img0.gif, img1.gif)
      imageNum: 2
    };

    const canvas = document.getElementById("appletCanvas");
    const ctx = canvas.getContext("2d");

    let isRunning = true;
    let mouseX = 0, mouseY = 0;
    let lastFrameTime = 0;
    let lastImageSwitchTime = 0;

    // ブロック画像の読み込みカウンタ
    const blockImages = [];
    let imagesLoaded = 0;

    // ブロックを保持する配列
    let blocks = [];

    // ◆◆◆ ウィンドウサイズに合わせてキャンバスをリサイズ ◆◆◆
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    // ◆◆◆ 画像を読み込み、全て完了したら初期化を呼ぶ ◆◆◆
    function loadImagesAndInit() {
      for (let i = 0; i < config.imageNum; i++) {
        const img = new Image();
        img.src = config.imageBaseString + i + ".gif";
        img.onload = () => {
          imagesLoaded++;
          if (imagesLoaded === config.imageNum) {
            initApplet();
          }
        };
        img.onerror = () => {
          console.warn("画像の読み込みに失敗しました:", img.src);
          // 読み込み失敗時は代替画像を生成
          const fallbackCanvas = document.createElement("canvas");
          fallbackCanvas.width = config.pixelSize;
          fallbackCanvas.height = config.pixelSize;
          const fctx = fallbackCanvas.getContext("2d");
          fctx.fillStyle = i % 2 === 0 ? "#888888" : "#444444";
          fctx.fillRect(0, 0, config.pixelSize, config.pixelSize);
          blockImages[i] = fallbackCanvas;
          imagesLoaded++;
          if (imagesLoaded === config.imageNum) {
            initApplet();
          }
        };
        blockImages.push(img);
      }
    }

    // ◆◆◆ MyBlockクラス：各ブロックの動作を定義 ◆◆◆
    class MyBlock {
      constructor(sx, sy, gx, gy, maxState) {
        // 開始位置(sx, sy), 目標位置(gx, gy)
        this.sx = sx;
        this.sy = sy;
        this.gx = gx;
        this.gy = gy;
        // 初期位置はキャンバス内のランダムな位置
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.dx = 0;
        this.dy = 0;
        // ランダムなステート
        this.state = Math.floor(Math.random() * (maxState + 1));
        this.maxState = maxState;
        // 移動制御用
        this.a = 1;
        this.b = 0.1;
        // ある程度近づくための初期速度
        const step = 30;
        this.dx = (this.gx - this.sx) / step;
        this.dy = (this.gy - this.sy) / step;
      }

      setPosition(x, y) {
        this.x = x;
        this.y = y;
      }

      // マウスが動いていない場合の更新
      update() {
        this.x += this.dx;
        this.y += this.dy;
        if (this.x - this.gx > 0) {
          this.dx += -this.a - this.b * this.dx;
        } else {
          this.dx += this.a - this.b * this.dx;
        }
        if (this.y - this.gy > 0) {
          this.dy += -this.a - this.b * this.dy;
        } else {
          this.dy += this.a - this.b * this.dy;
        }
      }

      // マウス座標がある場合の更新
      updateWithMouse(mx, my) {
        const dist = Math.sqrt((this.x - mx) ** 2 + (this.y - my) ** 2);
        this.dx += (this.x - mx) / (dist + 1);
        this.dy += (this.y - my) / (dist + 1);
        this.x += this.dx;
        this.y += this.dy;

        // 目標への吸着挙動
        if (this.x - this.gx > 0) {
          this.dx += -this.a - this.b * this.dx;
        } else {
          this.dx += this.a - this.b * this.dx;
        }
        if (this.y - this.gy > 0) {
          this.dy += -this.a - this.b * this.dy;
        } else {
          this.dy += this.a - this.b * this.dy;
        }
      }

      // 画像の切り替え
      setNextState() {
        this.state = (this.state + 1) % (this.maxState + 1);
      }
    }

    // ◆◆◆ 文字→ブロック生成の初期化処理 ◆◆◆
    function initApplet() {
      blocks = [];

      // 改行で行を分割
      const lines = config.Title.split("\n");
      const fontSize = 12;       // 文字描画用フォントサイズ
      const lineSpacing = 14;    // 行間
      const padding = 4;         // 左右余白

      const tmpCanvas = document.createElement("canvas");
      const tmpCtx = tmpCanvas.getContext("2d");
      tmpCtx.font = `${fontSize}px 'Press Start 2P', 'MS PGothic'`;

      // 最大の行幅を計測
      let maxLineWidth = 0;
      lines.forEach(line => {
        const w = tmpCtx.measureText(line).width;
        if (w > maxLineWidth) {
          maxLineWidth = w;
        }
      });

      // 総幅と総高さを計算
      const totalWidth = Math.ceil(maxLineWidth) + padding * 2;
      const totalHeight = lineSpacing * lines.length;

      // キャンバス中心に配置するためのオフセット
      const offsetX = (canvas.width - totalWidth * config.pixelSize) / 2;
      const offsetY = (canvas.height - totalHeight * config.pixelSize) / 2;

      // 行を順番に描画して、その黒ピクセルからブロックを生成
      let currentY = 0;
      lines.forEach(line => {
        if (!line) {
          currentY += lineSpacing;
          return;
        }

        const lineCanvas = document.createElement("canvas");
        lineCanvas.width = totalWidth;
        lineCanvas.height = lineSpacing;
        const lineCtx = lineCanvas.getContext("2d");

        lineCtx.fillStyle = "#ffffff";
        lineCtx.fillRect(0, 0, lineCanvas.width, lineCanvas.height);
        lineCtx.font = `${fontSize}px 'Press Start 2P', 'MS PGothic'`;
        lineCtx.fillStyle = "#000000";
        lineCtx.textBaseline = "top";
        lineCtx.fillText(line, padding, 0);

        const imageData = lineCtx.getImageData(0, 0, lineCanvas.width, lineCanvas.height);
        const data = imageData.data;
        const threshold = 200;
        for (let y = 0; y < lineCanvas.height; y++) {
          for (let x = 0; x < lineCanvas.width; x++) {
            const index = (y * lineCanvas.width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            if (r < threshold && g < threshold && b < threshold) {
              const scaledX = x * config.pixelSize;
              const scaledY = (currentY + y) * config.pixelSize;
              const targetX = scaledX + offsetX;
              const targetY = scaledY + offsetY;

              const maxState = config.imageNum - 1;
              const block = new MyBlock(0, 0, targetX, targetY, maxState);
              blocks.push(block);
            }
          }
        }
        currentY += lineSpacing;
      });

      // アニメーション開始
      requestAnimationFrame(animate);
    }

    // ◆◆◆ 毎フレームの描画処理 ◆◆◆
    function animate(timestamp) {
      if (!isRunning) {
        // 一時停止中でもフレームループは継続
        requestAnimationFrame(animate);
        return;
      }
      
      // アニメーション更新のタイミング
      if (!lastFrameTime) lastFrameTime = timestamp;
      if (timestamp - lastFrameTime >= config.animationInterval) {
        blocks.forEach(block => {
          if (mouseX === 0 && mouseY === 0) {
            block.update();
          } else {
            block.updateWithMouse(mouseX, mouseY);
          }
        });
        lastFrameTime = timestamp;
      }
      
      // 画像ステート切り替えのタイミング
      if (!lastImageSwitchTime) lastImageSwitchTime = timestamp;
      if (timestamp - lastImageSwitchTime >= config.imageSwitchInterval) {
        blocks.forEach(block => block.setNextState());
        lastImageSwitchTime = timestamp;
      }
      
      // キャンバスをクリアしてブロック描画
      ctx.fillStyle = config.backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      blocks.forEach(block => {
        const state = block.state;
        const img = blockImages[state];
        if (img && img.complete) {
          ctx.drawImage(img, block.x, block.y, config.pixelSize, config.pixelSize);
        } else {
          // ロード失敗時の代替色
          ctx.fillStyle = state % 2 === 0 ? "#888888" : "#444444";
          ctx.fillRect(block.x, block.y, config.pixelSize, config.pixelSize);
        }
      });
      
      requestAnimationFrame(animate);
    }

    // ◆◆◆ イベントリスナー登録 ◆◆◆
    // ウィンドウリサイズ時の処理
    window.addEventListener("resize", () => {
      resizeCanvas();
      // リサイズと同時に再計算をするならここで initApplet() を呼ぶ
      // ただしブロックが毎回初期位置に戻るため、好みに応じて再計算を行うか判断してください。
      initApplet();
    });

    // マウス操作
    canvas.addEventListener("mousemove", function(e) {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });
    canvas.addEventListener("mouseout", function() {
      mouseX = 0;
      mouseY = 0;
    });
    canvas.addEventListener("mousedown", function(e) {
      // シングルクリック判定
      if (e.detail === 1) {
        setTimeout(() => {
          if (e.detail === 1) {
            isRunning = !isRunning; // 一時停止／再開
          }
        }, 200);
      }
    });
    canvas.addEventListener("dblclick", function() {
      // ダブルクリックしたらブロックをランダム位置へ
      blocks.forEach(block => {
        block.setPosition(Math.random() * canvas.width, Math.random() * canvas.height);
      });
    });

    // ◆◆◆ ページ読み込み時に実行 ◆◆◆
    window.addEventListener("load", () => {
      resizeCanvas();       // キャンバスを全画面に
      loadImagesAndInit();  // 画像を読み込み、すべて完了後にinitApplet()を実行
    });
  </script>
</body>
</html>
